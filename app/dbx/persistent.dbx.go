// AUTOGENERATED BY storj.io/dbx
// DO NOT EDIT.

package dbx

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	"github.com/lib/pq"
	"github.com/mattn/go-sqlite3"
	"math/rand"
)

// Prevent conditional imports from causing build failures
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint
var _ sync.Mutex

var (
	WrapErr = func(err *Error) error { return err }
	Logger  func(format string, args ...interface{})

	errTooManyRows       = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate       = errors.New("empty update")
)

func logError(format string, args ...interface{}) {
	if Logger != nil {
		Logger(format, args...)
	}
}

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err         error
	Code        ErrorCode
	Driver      string
	Constraint  string
	QuerySuffix string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	e := &Error{Err: err}
	switch err {
	case sql.ErrNoRows:
		e.Code = ErrorCode_NoRows
	case sql.ErrTxDone:
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err:    errUnsupportedDriver,
		Code:   ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err:  errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows(query_suffix string) error {
	return wrapErr(&Error{
		Err:         errTooManyRows,
		Code:        ErrorCode_TooManyRows,
		QuerySuffix: query_suffix,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err:        err,
		Code:       ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

type driver interface {
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
}

var (
	notAPointer     = errors.New("destination not a pointer")
	lossyConversion = errors.New("lossy conversion")
)

type DB struct {
	*sql.DB
	dbMethods

	Hooks struct {
		Now func() time.Time
	}
}

func Open(driver, source string) (db *DB, err error) {
	var sql_db *sql.DB
	switch driver {
	case "postgres":
		sql_db, err = openpostgres(source)
	case "sqlite3":
		sql_db, err = opensqlite3(source)
	default:
		return nil, unsupportedDriver(driver)
	}
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

	db = &DB{
		DB: sql_db,
	}
	db.Hooks.Now = time.Now

	switch driver {
	case "postgres":
		db.dbMethods = newpostgres(db)
	case "sqlite3":
		db.dbMethods = newsqlite3(db)
	default:
		return nil, unsupportedDriver(driver)
	}

	return db, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		Tx:        tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func (obj *DB) NewRx() *Rx {
	return &Rx{db: obj}
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			logError("delete-all: rollback failed: %v", db.makeErr(err_rollback))
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	Tx *sql.Tx
	txMethods
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

type postgresImpl struct {
	db      *DB
	dialect __sqlbundle_postgres
	driver  driver
}

func (obj *postgresImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *postgresImpl) logStmt(stmt string, args ...interface{}) {
	postgresLogStmt(stmt, args...)
}

func (obj *postgresImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type postgresDB struct {
	db *DB
	*postgresImpl
}

func newpostgres(db *DB) *postgresDB {
	return &postgresDB{
		db: db,
		postgresImpl: &postgresImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *postgresDB) Schema() string {
	return `CREATE TABLE gerrit_users (
	gerrit_username text NOT NULL,
	chat_id text NOT NULL,
	last_report timestamp,
	PRIMARY KEY ( gerrit_username )
);
CREATE TABLE inline_comments (
	comment_id text NOT NULL,
	updated_at timestamp NOT NULL,
	PRIMARY KEY ( comment_id )
);
CREATE TABLE patchset_announcements (
	num serial NOT NULL,
	project_name text NOT NULL,
	change_num integer NOT NULL,
	patchset_num integer NOT NULL,
	message_handle text NOT NULL,
	ts timestamp NOT NULL,
	PRIMARY KEY ( num )
);
CREATE TABLE team_configs (
	config_key text NOT NULL,
	config_value text NOT NULL,
	PRIMARY KEY ( config_key )
);
CREATE INDEX last_report_idx ON gerrit_users ( last_report );
CREATE INDEX updated_at_idx ON inline_comments ( updated_at );
CREATE INDEX patchset_announcement_project_name_change_num_patchset_num_idx ON patchset_announcements ( project_name, change_num, patchset_num );
CREATE INDEX patchset_announcement_ts_idx ON patchset_announcements ( ts );`
}

func (obj *postgresDB) wrapTx(tx *sql.Tx) txMethods {
	return &postgresTx{
		dialectTx: dialectTx{tx: tx},
		postgresImpl: &postgresImpl{
			db:     obj.db,
			driver: tx,
		},
	}
}

type postgresTx struct {
	dialectTx
	*postgresImpl
}

func postgresLogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type sqlite3Impl struct {
	db      *DB
	dialect __sqlbundle_sqlite3
	driver  driver
}

func (obj *sqlite3Impl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *sqlite3Impl) logStmt(stmt string, args ...interface{}) {
	sqlite3LogStmt(stmt, args...)
}

func (obj *sqlite3Impl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type sqlite3DB struct {
	db *DB
	*sqlite3Impl
}

func newsqlite3(db *DB) *sqlite3DB {
	return &sqlite3DB{
		db: db,
		sqlite3Impl: &sqlite3Impl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *sqlite3DB) Schema() string {
	return `CREATE TABLE gerrit_users (
	gerrit_username TEXT NOT NULL,
	chat_id TEXT NOT NULL,
	last_report TIMESTAMP,
	PRIMARY KEY ( gerrit_username )
);
CREATE TABLE inline_comments (
	comment_id TEXT NOT NULL,
	updated_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( comment_id )
);
CREATE TABLE patchset_announcements (
	num INTEGER NOT NULL,
	project_name TEXT NOT NULL,
	change_num INTEGER NOT NULL,
	patchset_num INTEGER NOT NULL,
	message_handle TEXT NOT NULL,
	ts TIMESTAMP NOT NULL,
	PRIMARY KEY ( num )
);
CREATE TABLE team_configs (
	config_key TEXT NOT NULL,
	config_value TEXT NOT NULL,
	PRIMARY KEY ( config_key )
);
CREATE INDEX last_report_idx ON gerrit_users ( last_report );
CREATE INDEX updated_at_idx ON inline_comments ( updated_at );
CREATE INDEX patchset_announcement_project_name_change_num_patchset_num_idx ON patchset_announcements ( project_name, change_num, patchset_num );
CREATE INDEX patchset_announcement_ts_idx ON patchset_announcements ( ts );`
}

func (obj *sqlite3DB) wrapTx(tx *sql.Tx) txMethods {
	return &sqlite3Tx{
		dialectTx: dialectTx{tx: tx},
		sqlite3Impl: &sqlite3Impl{
			db:     obj.db,
			driver: tx,
		},
	}
}

type sqlite3Tx struct {
	dialectTx
	*sqlite3Impl
}

func sqlite3LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pretty []interface{}

func (p pretty) Format(f fmt.State, c rune) {
	fmt.Fprint(f, "[")
nextval:
	for i, val := range p {
		if i > 0 {
			fmt.Fprint(f, ", ")
		}
		rv := reflect.ValueOf(val)
		if rv.Kind() == reflect.Ptr {
			if rv.IsNil() {
				fmt.Fprint(f, "NULL")
				continue
			}
			val = rv.Elem().Interface()
		}
		switch v := val.(type) {
		case string:
			fmt.Fprintf(f, "%q", v)
		case time.Time:
			fmt.Fprintf(f, "%s", v.Format(time.RFC3339Nano))
		case []byte:
			for _, b := range v {
				if !unicode.IsPrint(rune(b)) {
					fmt.Fprintf(f, "%#x", v)
					continue nextval
				}
			}
			fmt.Fprintf(f, "%q", v)
		default:
			fmt.Fprintf(f, "%v", v)
		}
	}
	fmt.Fprint(f, "]")
}

type GerritUser struct {
	GerritUsername string
	ChatId         string
	LastReport     *time.Time
}

func (GerritUser) _Table() string { return "gerrit_users" }

type GerritUser_Create_Fields struct {
	LastReport GerritUser_LastReport_Field
}

type GerritUser_Update_Fields struct {
	LastReport GerritUser_LastReport_Field
}

type GerritUser_GerritUsername_Field struct {
	_set   bool
	_null  bool
	_value string
}

func GerritUser_GerritUsername(v string) GerritUser_GerritUsername_Field {
	return GerritUser_GerritUsername_Field{_set: true, _value: v}
}

func (f GerritUser_GerritUsername_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (GerritUser_GerritUsername_Field) _Column() string { return "gerrit_username" }

type GerritUser_ChatId_Field struct {
	_set   bool
	_null  bool
	_value string
}

func GerritUser_ChatId(v string) GerritUser_ChatId_Field {
	return GerritUser_ChatId_Field{_set: true, _value: v}
}

func (f GerritUser_ChatId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (GerritUser_ChatId_Field) _Column() string { return "chat_id" }

type GerritUser_LastReport_Field struct {
	_set   bool
	_null  bool
	_value *time.Time
}

func GerritUser_LastReport(v time.Time) GerritUser_LastReport_Field {
	v = toUTC(v)
	return GerritUser_LastReport_Field{_set: true, _value: &v}
}

func GerritUser_LastReport_Raw(v *time.Time) GerritUser_LastReport_Field {
	if v == nil {
		return GerritUser_LastReport_Null()
	}
	return GerritUser_LastReport(*v)
}

func GerritUser_LastReport_Null() GerritUser_LastReport_Field {
	return GerritUser_LastReport_Field{_set: true, _null: true}
}

func (f GerritUser_LastReport_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f GerritUser_LastReport_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (GerritUser_LastReport_Field) _Column() string { return "last_report" }

type InlineComment struct {
	CommentId string
	UpdatedAt time.Time
}

func (InlineComment) _Table() string { return "inline_comments" }

type InlineComment_Update_Fields struct {
	UpdatedAt InlineComment_UpdatedAt_Field
}

type InlineComment_CommentId_Field struct {
	_set   bool
	_null  bool
	_value string
}

func InlineComment_CommentId(v string) InlineComment_CommentId_Field {
	return InlineComment_CommentId_Field{_set: true, _value: v}
}

func (f InlineComment_CommentId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (InlineComment_CommentId_Field) _Column() string { return "comment_id" }

type InlineComment_UpdatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func InlineComment_UpdatedAt(v time.Time) InlineComment_UpdatedAt_Field {
	v = toUTC(v)
	return InlineComment_UpdatedAt_Field{_set: true, _value: v}
}

func (f InlineComment_UpdatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (InlineComment_UpdatedAt_Field) _Column() string { return "updated_at" }

type PatchsetAnnouncement struct {
	Num           int
	ProjectName   string
	ChangeNum     int
	PatchsetNum   int
	MessageHandle string
	Ts            time.Time
}

func (PatchsetAnnouncement) _Table() string { return "patchset_announcements" }

type PatchsetAnnouncement_Update_Fields struct {
}

type PatchsetAnnouncement_Num_Field struct {
	_set   bool
	_null  bool
	_value int
}

func PatchsetAnnouncement_Num(v int) PatchsetAnnouncement_Num_Field {
	return PatchsetAnnouncement_Num_Field{_set: true, _value: v}
}

func (f PatchsetAnnouncement_Num_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PatchsetAnnouncement_Num_Field) _Column() string { return "num" }

type PatchsetAnnouncement_ProjectName_Field struct {
	_set   bool
	_null  bool
	_value string
}

func PatchsetAnnouncement_ProjectName(v string) PatchsetAnnouncement_ProjectName_Field {
	return PatchsetAnnouncement_ProjectName_Field{_set: true, _value: v}
}

func (f PatchsetAnnouncement_ProjectName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PatchsetAnnouncement_ProjectName_Field) _Column() string { return "project_name" }

type PatchsetAnnouncement_ChangeNum_Field struct {
	_set   bool
	_null  bool
	_value int
}

func PatchsetAnnouncement_ChangeNum(v int) PatchsetAnnouncement_ChangeNum_Field {
	return PatchsetAnnouncement_ChangeNum_Field{_set: true, _value: v}
}

func (f PatchsetAnnouncement_ChangeNum_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PatchsetAnnouncement_ChangeNum_Field) _Column() string { return "change_num" }

type PatchsetAnnouncement_PatchsetNum_Field struct {
	_set   bool
	_null  bool
	_value int
}

func PatchsetAnnouncement_PatchsetNum(v int) PatchsetAnnouncement_PatchsetNum_Field {
	return PatchsetAnnouncement_PatchsetNum_Field{_set: true, _value: v}
}

func (f PatchsetAnnouncement_PatchsetNum_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PatchsetAnnouncement_PatchsetNum_Field) _Column() string { return "patchset_num" }

type PatchsetAnnouncement_MessageHandle_Field struct {
	_set   bool
	_null  bool
	_value string
}

func PatchsetAnnouncement_MessageHandle(v string) PatchsetAnnouncement_MessageHandle_Field {
	return PatchsetAnnouncement_MessageHandle_Field{_set: true, _value: v}
}

func (f PatchsetAnnouncement_MessageHandle_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PatchsetAnnouncement_MessageHandle_Field) _Column() string { return "message_handle" }

type PatchsetAnnouncement_Ts_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func PatchsetAnnouncement_Ts(v time.Time) PatchsetAnnouncement_Ts_Field {
	v = toUTC(v)
	return PatchsetAnnouncement_Ts_Field{_set: true, _value: v}
}

func (f PatchsetAnnouncement_Ts_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (PatchsetAnnouncement_Ts_Field) _Column() string { return "ts" }

type TeamConfig struct {
	ConfigKey   string
	ConfigValue string
}

func (TeamConfig) _Table() string { return "team_configs" }

type TeamConfig_Update_Fields struct {
	ConfigValue TeamConfig_ConfigValue_Field
}

type TeamConfig_ConfigKey_Field struct {
	_set   bool
	_null  bool
	_value string
}

func TeamConfig_ConfigKey(v string) TeamConfig_ConfigKey_Field {
	return TeamConfig_ConfigKey_Field{_set: true, _value: v}
}

func (f TeamConfig_ConfigKey_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (TeamConfig_ConfigKey_Field) _Column() string { return "config_key" }

type TeamConfig_ConfigValue_Field struct {
	_set   bool
	_null  bool
	_value string
}

func TeamConfig_ConfigValue(v string) TeamConfig_ConfigValue_Field {
	return TeamConfig_ConfigValue_Field{_set: true, _value: v}
}

func (f TeamConfig_ConfigValue_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (TeamConfig_ConfigValue_Field) _Column() string { return "config_value" }

func toUTC(t time.Time) time.Time {
	return t.UTC()
}

func toDate(t time.Time) time.Time {
	// keep up the minute portion so that translations between timezones will
	// continue to reflect properly.
	return t.Truncate(time.Minute)
}

//
// runtime support for building sql statements
//

type __sqlbundle_SQL interface {
	Render() string

	private()
}

type __sqlbundle_Dialect interface {
	Rebind(sql string) string
}

type __sqlbundle_RenderOp int

const (
	__sqlbundle_NoFlatten __sqlbundle_RenderOp = iota
	__sqlbundle_NoTerminate
)

func __sqlbundle_Render(dialect __sqlbundle_Dialect, sql __sqlbundle_SQL, ops ...__sqlbundle_RenderOp) string {
	out := sql.Render()

	flatten := true
	terminate := true
	for _, op := range ops {
		switch op {
		case __sqlbundle_NoFlatten:
			flatten = false
		case __sqlbundle_NoTerminate:
			terminate = false
		}
	}

	if flatten {
		out = __sqlbundle_flattenSQL(out)
	}
	if terminate {
		out += ";"
	}

	return dialect.Rebind(out)
}

func __sqlbundle_flattenSQL(x string) string {
	// trim whitespace from beginning and end
	s, e := 0, len(x)-1
	for s < len(x) && (x[s] == ' ' || x[s] == '\t' || x[s] == '\n') {
		s++
	}
	for s <= e && (x[e] == ' ' || x[e] == '\t' || x[e] == '\n') {
		e--
	}
	if s > e {
		return ""
	}
	x = x[s : e+1]

	// check for whitespace that needs fixing
	wasSpace := false
	for i := 0; i < len(x); i++ {
		r := x[i]
		justSpace := r == ' '
		if (wasSpace && justSpace) || r == '\t' || r == '\n' {
			// whitespace detected, start writing a new string
			var result strings.Builder
			result.Grow(len(x))
			if wasSpace {
				result.WriteString(x[:i-1])
			} else {
				result.WriteString(x[:i])
			}
			for p := i; p < len(x); p++ {
				for p < len(x) && (x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteByte(' ')

				start := p
				for p < len(x) && !(x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteString(x[start:p])
			}

			return result.String()
		}
		wasSpace = justSpace
	}

	// no problematic whitespace found
	return x
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_postgres struct{}

func (p __sqlbundle_postgres) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_sqlite3 struct{}

func (s __sqlbundle_sqlite3) Rebind(sql string) string {
	return sql
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_cockroach struct{}

func (p __sqlbundle_cockroach) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgx struct{}

func (p __sqlbundle_pgx) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgxcockroach struct{}

func (p __sqlbundle_pgxcockroach) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

type __sqlbundle_Literal string

func (__sqlbundle_Literal) private() {}

func (l __sqlbundle_Literal) Render() string { return string(l) }

type __sqlbundle_Literals struct {
	Join string
	SQLs []__sqlbundle_SQL
}

func (__sqlbundle_Literals) private() {}

func (l __sqlbundle_Literals) Render() string {
	var out bytes.Buffer

	first := true
	for _, sql := range l.SQLs {
		if sql == nil {
			continue
		}
		if !first {
			out.WriteString(l.Join)
		}
		first = false
		out.WriteString(sql.Render())
	}

	return out.String()
}

type __sqlbundle_Condition struct {
	// set at compile/embed time
	Name  string
	Left  string
	Equal bool
	Right string

	// set at runtime
	Null bool
}

func (*__sqlbundle_Condition) private() {}

func (c *__sqlbundle_Condition) Render() string {
	// TODO(jeff): maybe check if we can use placeholders instead of the
	// literal null: this would make the templates easier.

	switch {
	case c.Equal && c.Null:
		return c.Left + " is null"
	case c.Equal && !c.Null:
		return c.Left + " = " + c.Right
	case !c.Equal && c.Null:
		return c.Left + " is not null"
	case !c.Equal && !c.Null:
		return c.Left + " != " + c.Right
	default:
		panic("unhandled case")
	}
}

type __sqlbundle_Hole struct {
	// set at compiile/embed time
	Name string

	// set at runtime or possibly embed time
	SQL __sqlbundle_SQL
}

func (*__sqlbundle_Hole) private() {}

func (h *__sqlbundle_Hole) Render() string {
	if h.SQL == nil {
		return ""
	}
	return h.SQL.Render()
}

//
// end runtime support for building sql statements
//

type ConfigValue_Row struct {
	ConfigValue string
}

type MessageHandle_Row struct {
	MessageHandle string
}

func (obj *postgresImpl) CreateNoReturn_GerritUser(ctx context.Context,
	gerrit_user_gerrit_username GerritUser_GerritUsername_Field,
	gerrit_user_chat_id GerritUser_ChatId_Field,
	optional GerritUser_Create_Fields) (
	err error) {
	__gerrit_username_val := gerrit_user_gerrit_username.value()
	__chat_id_val := gerrit_user_chat_id.value()
	__last_report_val := optional.LastReport.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO gerrit_users ( gerrit_username, chat_id, last_report ) VALUES ( ?, ?, ? )")

	var __values []interface{}
	__values = append(__values, __gerrit_username_val, __chat_id_val, __last_report_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *postgresImpl) CreateNoReturn_TeamConfig(ctx context.Context,
	team_config_config_key TeamConfig_ConfigKey_Field,
	team_config_config_value TeamConfig_ConfigValue_Field) (
	err error) {
	__config_key_val := team_config_config_key.value()
	__config_value_val := team_config_config_value.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO team_configs ( config_key, config_value ) VALUES ( ?, ? )")

	var __values []interface{}
	__values = append(__values, __config_key_val, __config_value_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *postgresImpl) CreateNoReturn_PatchsetAnnouncement(ctx context.Context,
	patchset_announcement_project_name PatchsetAnnouncement_ProjectName_Field,
	patchset_announcement_change_num PatchsetAnnouncement_ChangeNum_Field,
	patchset_announcement_patchset_num PatchsetAnnouncement_PatchsetNum_Field,
	patchset_announcement_message_handle PatchsetAnnouncement_MessageHandle_Field) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__project_name_val := patchset_announcement_project_name.value()
	__change_num_val := patchset_announcement_change_num.value()
	__patchset_num_val := patchset_announcement_patchset_num.value()
	__message_handle_val := patchset_announcement_message_handle.value()
	__ts_val := __now.UTC()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO patchset_announcements ( project_name, change_num, patchset_num, message_handle, ts ) VALUES ( ?, ?, ?, ?, ? )")

	var __values []interface{}
	__values = append(__values, __project_name_val, __change_num_val, __patchset_num_val, __message_handle_val, __ts_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *postgresImpl) Get_GerritUser_By_GerritUsername(ctx context.Context,
	gerrit_user_gerrit_username GerritUser_GerritUsername_Field) (
	gerrit_user *GerritUser, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT gerrit_users.gerrit_username, gerrit_users.chat_id, gerrit_users.last_report FROM gerrit_users WHERE gerrit_users.gerrit_username = ?")

	var __values []interface{}
	__values = append(__values, gerrit_user_gerrit_username.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	gerrit_user = &GerritUser{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&gerrit_user.GerritUsername, &gerrit_user.ChatId, &gerrit_user.LastReport)
	if err != nil {
		return (*GerritUser)(nil), obj.makeErr(err)
	}
	return gerrit_user, nil

}

func (obj *postgresImpl) All_GerritUser_By_LastReport_Less(ctx context.Context,
	gerrit_user_last_report_less GerritUser_LastReport_Field) (
	rows []*GerritUser, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT gerrit_users.gerrit_username, gerrit_users.chat_id, gerrit_users.last_report FROM gerrit_users WHERE gerrit_users.last_report < ?")

	var __values []interface{}
	__values = append(__values, gerrit_user_last_report_less.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		gerrit_user := &GerritUser{}
		err = __rows.Scan(&gerrit_user.GerritUsername, &gerrit_user.ChatId, &gerrit_user.LastReport)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, gerrit_user)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_TeamConfig_ConfigValue_By_ConfigKey(ctx context.Context,
	team_config_config_key TeamConfig_ConfigKey_Field) (
	row *ConfigValue_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT team_configs.config_value FROM team_configs WHERE team_configs.config_key = ?")

	var __values []interface{}
	__values = append(__values, team_config_config_key.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	row = &ConfigValue_Row{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&row.ConfigValue)
	if err != nil {
		return (*ConfigValue_Row)(nil), obj.makeErr(err)
	}
	return row, nil

}

func (obj *postgresImpl) All_PatchsetAnnouncement_MessageHandle_By_ProjectName_And_ChangeNum_And_PatchsetNum(ctx context.Context,
	patchset_announcement_project_name PatchsetAnnouncement_ProjectName_Field,
	patchset_announcement_change_num PatchsetAnnouncement_ChangeNum_Field,
	patchset_announcement_patchset_num PatchsetAnnouncement_PatchsetNum_Field) (
	rows []*MessageHandle_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT patchset_announcements.message_handle FROM patchset_announcements WHERE patchset_announcements.project_name = ? AND patchset_announcements.change_num = ? AND patchset_announcements.patchset_num = ?")

	var __values []interface{}
	__values = append(__values, patchset_announcement_project_name.value(), patchset_announcement_change_num.value(), patchset_announcement_patchset_num.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &MessageHandle_Row{}
		err = __rows.Scan(&row.MessageHandle)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) UpdateNoReturn_GerritUser_By_GerritUsername(ctx context.Context,
	gerrit_user_gerrit_username GerritUser_GerritUsername_Field,
	update GerritUser_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE gerrit_users SET "), __sets, __sqlbundle_Literal(" WHERE gerrit_users.gerrit_username = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.LastReport._set {
		__values = append(__values, update.LastReport.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_report = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, gerrit_user_gerrit_username.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *postgresImpl) Update_InlineComment_By_CommentId(ctx context.Context,
	inline_comment_comment_id InlineComment_CommentId_Field,
	update InlineComment_Update_Fields) (
	inline_comment *InlineComment, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE inline_comments SET "), __sets, __sqlbundle_Literal(" WHERE inline_comments.comment_id = ? RETURNING inline_comments.comment_id, inline_comments.updated_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.UpdatedAt._set {
		__values = append(__values, update.UpdatedAt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("updated_at = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, inline_comment_comment_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	inline_comment = &InlineComment{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&inline_comment.CommentId, &inline_comment.UpdatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return inline_comment, nil
}

func (obj *postgresImpl) UpdateNoReturn_TeamConfig_By_ConfigKey(ctx context.Context,
	team_config_config_key TeamConfig_ConfigKey_Field,
	update TeamConfig_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE team_configs SET "), __sets, __sqlbundle_Literal(" WHERE team_configs.config_key = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.ConfigValue._set {
		__values = append(__values, update.ConfigValue.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("config_value = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, team_config_config_key.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *postgresImpl) Delete_InlineComment_By_UpdatedAt_Less(ctx context.Context,
	inline_comment_updated_at_less InlineComment_UpdatedAt_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM inline_comments WHERE inline_comments.updated_at < ?")

	var __values []interface{}
	__values = append(__values, inline_comment_updated_at_less.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *postgresImpl) Delete_PatchsetAnnouncement_By_Ts_Less(ctx context.Context,
	patchset_announcement_ts_less PatchsetAnnouncement_Ts_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM patchset_announcements WHERE patchset_announcements.ts < ?")

	var __values []interface{}
	__values = append(__values, patchset_announcement_ts_less.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (impl postgresImpl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(*pq.Error); ok {
		if e.Code.Class() == "23" {
			return e.Constraint, true
		}
	}
	return "", false
}

func (obj *postgresImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM team_configs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM patchset_announcements;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM inline_comments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM gerrit_users;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *sqlite3Impl) CreateNoReturn_GerritUser(ctx context.Context,
	gerrit_user_gerrit_username GerritUser_GerritUsername_Field,
	gerrit_user_chat_id GerritUser_ChatId_Field,
	optional GerritUser_Create_Fields) (
	err error) {
	__gerrit_username_val := gerrit_user_gerrit_username.value()
	__chat_id_val := gerrit_user_chat_id.value()
	__last_report_val := optional.LastReport.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO gerrit_users ( gerrit_username, chat_id, last_report ) VALUES ( ?, ?, ? )")

	var __values []interface{}
	__values = append(__values, __gerrit_username_val, __chat_id_val, __last_report_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) CreateNoReturn_TeamConfig(ctx context.Context,
	team_config_config_key TeamConfig_ConfigKey_Field,
	team_config_config_value TeamConfig_ConfigValue_Field) (
	err error) {
	__config_key_val := team_config_config_key.value()
	__config_value_val := team_config_config_value.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO team_configs ( config_key, config_value ) VALUES ( ?, ? )")

	var __values []interface{}
	__values = append(__values, __config_key_val, __config_value_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) CreateNoReturn_PatchsetAnnouncement(ctx context.Context,
	patchset_announcement_project_name PatchsetAnnouncement_ProjectName_Field,
	patchset_announcement_change_num PatchsetAnnouncement_ChangeNum_Field,
	patchset_announcement_patchset_num PatchsetAnnouncement_PatchsetNum_Field,
	patchset_announcement_message_handle PatchsetAnnouncement_MessageHandle_Field) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__project_name_val := patchset_announcement_project_name.value()
	__change_num_val := patchset_announcement_change_num.value()
	__patchset_num_val := patchset_announcement_patchset_num.value()
	__message_handle_val := patchset_announcement_message_handle.value()
	__ts_val := __now.UTC()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO patchset_announcements ( project_name, change_num, patchset_num, message_handle, ts ) VALUES ( ?, ?, ?, ?, ? )")

	var __values []interface{}
	__values = append(__values, __project_name_val, __change_num_val, __patchset_num_val, __message_handle_val, __ts_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) Get_GerritUser_By_GerritUsername(ctx context.Context,
	gerrit_user_gerrit_username GerritUser_GerritUsername_Field) (
	gerrit_user *GerritUser, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT gerrit_users.gerrit_username, gerrit_users.chat_id, gerrit_users.last_report FROM gerrit_users WHERE gerrit_users.gerrit_username = ?")

	var __values []interface{}
	__values = append(__values, gerrit_user_gerrit_username.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	gerrit_user = &GerritUser{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&gerrit_user.GerritUsername, &gerrit_user.ChatId, &gerrit_user.LastReport)
	if err != nil {
		return (*GerritUser)(nil), obj.makeErr(err)
	}
	return gerrit_user, nil

}

func (obj *sqlite3Impl) All_GerritUser_By_LastReport_Less(ctx context.Context,
	gerrit_user_last_report_less GerritUser_LastReport_Field) (
	rows []*GerritUser, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT gerrit_users.gerrit_username, gerrit_users.chat_id, gerrit_users.last_report FROM gerrit_users WHERE gerrit_users.last_report < ?")

	var __values []interface{}
	__values = append(__values, gerrit_user_last_report_less.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		gerrit_user := &GerritUser{}
		err = __rows.Scan(&gerrit_user.GerritUsername, &gerrit_user.ChatId, &gerrit_user.LastReport)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, gerrit_user)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_TeamConfig_ConfigValue_By_ConfigKey(ctx context.Context,
	team_config_config_key TeamConfig_ConfigKey_Field) (
	row *ConfigValue_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT team_configs.config_value FROM team_configs WHERE team_configs.config_key = ?")

	var __values []interface{}
	__values = append(__values, team_config_config_key.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	row = &ConfigValue_Row{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&row.ConfigValue)
	if err != nil {
		return (*ConfigValue_Row)(nil), obj.makeErr(err)
	}
	return row, nil

}

func (obj *sqlite3Impl) All_PatchsetAnnouncement_MessageHandle_By_ProjectName_And_ChangeNum_And_PatchsetNum(ctx context.Context,
	patchset_announcement_project_name PatchsetAnnouncement_ProjectName_Field,
	patchset_announcement_change_num PatchsetAnnouncement_ChangeNum_Field,
	patchset_announcement_patchset_num PatchsetAnnouncement_PatchsetNum_Field) (
	rows []*MessageHandle_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT patchset_announcements.message_handle FROM patchset_announcements WHERE patchset_announcements.project_name = ? AND patchset_announcements.change_num = ? AND patchset_announcements.patchset_num = ?")

	var __values []interface{}
	__values = append(__values, patchset_announcement_project_name.value(), patchset_announcement_change_num.value(), patchset_announcement_patchset_num.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &MessageHandle_Row{}
		err = __rows.Scan(&row.MessageHandle)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) UpdateNoReturn_GerritUser_By_GerritUsername(ctx context.Context,
	gerrit_user_gerrit_username GerritUser_GerritUsername_Field,
	update GerritUser_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE gerrit_users SET "), __sets, __sqlbundle_Literal(" WHERE gerrit_users.gerrit_username = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.LastReport._set {
		__values = append(__values, update.LastReport.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_report = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, gerrit_user_gerrit_username.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) Update_InlineComment_By_CommentId(ctx context.Context,
	inline_comment_comment_id InlineComment_CommentId_Field,
	update InlineComment_Update_Fields) (
	inline_comment *InlineComment, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE inline_comments SET "), __sets, __sqlbundle_Literal(" WHERE inline_comments.comment_id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.UpdatedAt._set {
		__values = append(__values, update.UpdatedAt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("updated_at = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, inline_comment_comment_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	inline_comment = &InlineComment{}
	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT inline_comments.comment_id, inline_comments.updated_at FROM inline_comments WHERE inline_comments.comment_id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRowContext(ctx, __stmt_get, __args...).Scan(&inline_comment.CommentId, &inline_comment.UpdatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return inline_comment, nil
}

func (obj *sqlite3Impl) UpdateNoReturn_TeamConfig_By_ConfigKey(ctx context.Context,
	team_config_config_key TeamConfig_ConfigKey_Field,
	update TeamConfig_Update_Fields) (
	err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE team_configs SET "), __sets, __sqlbundle_Literal(" WHERE team_configs.config_key = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.ConfigValue._set {
		__values = append(__values, update.ConfigValue.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("config_value = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, team_config_config_key.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) Delete_InlineComment_By_UpdatedAt_Less(ctx context.Context,
	inline_comment_updated_at_less InlineComment_UpdatedAt_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM inline_comments WHERE inline_comments.updated_at < ?")

	var __values []interface{}
	__values = append(__values, inline_comment_updated_at_less.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) Delete_PatchsetAnnouncement_By_Ts_Less(ctx context.Context,
	patchset_announcement_ts_less PatchsetAnnouncement_Ts_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM patchset_announcements WHERE patchset_announcements.ts < ?")

	var __values []interface{}
	__values = append(__values, patchset_announcement_ts_less.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) getLastGerritUser(ctx context.Context,
	pk int64) (
	gerrit_user *GerritUser, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT gerrit_users.gerrit_username, gerrit_users.chat_id, gerrit_users.last_report FROM gerrit_users WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	gerrit_user = &GerritUser{}
	err = obj.driver.QueryRowContext(ctx, __stmt, pk).Scan(&gerrit_user.GerritUsername, &gerrit_user.ChatId, &gerrit_user.LastReport)
	if err != nil {
		return (*GerritUser)(nil), obj.makeErr(err)
	}
	return gerrit_user, nil

}

func (obj *sqlite3Impl) getLastTeamConfig(ctx context.Context,
	pk int64) (
	team_config *TeamConfig, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT team_configs.config_key, team_configs.config_value FROM team_configs WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	team_config = &TeamConfig{}
	err = obj.driver.QueryRowContext(ctx, __stmt, pk).Scan(&team_config.ConfigKey, &team_config.ConfigValue)
	if err != nil {
		return (*TeamConfig)(nil), obj.makeErr(err)
	}
	return team_config, nil

}

func (obj *sqlite3Impl) getLastPatchsetAnnouncement(ctx context.Context,
	pk int64) (
	patchset_announcement *PatchsetAnnouncement, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT patchset_announcements.num, patchset_announcements.project_name, patchset_announcements.change_num, patchset_announcements.patchset_num, patchset_announcements.message_handle, patchset_announcements.ts FROM patchset_announcements WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	patchset_announcement = &PatchsetAnnouncement{}
	err = obj.driver.QueryRowContext(ctx, __stmt, pk).Scan(&patchset_announcement.Num, &patchset_announcement.ProjectName, &patchset_announcement.ChangeNum, &patchset_announcement.PatchsetNum, &patchset_announcement.MessageHandle, &patchset_announcement.Ts)
	if err != nil {
		return (*PatchsetAnnouncement)(nil), obj.makeErr(err)
	}
	return patchset_announcement, nil

}

func (obj *sqlite3Impl) getLastInlineComment(ctx context.Context,
	pk int64) (
	inline_comment *InlineComment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT inline_comments.comment_id, inline_comments.updated_at FROM inline_comments WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	inline_comment = &InlineComment{}
	err = obj.driver.QueryRowContext(ctx, __stmt, pk).Scan(&inline_comment.CommentId, &inline_comment.UpdatedAt)
	if err != nil {
		return (*InlineComment)(nil), obj.makeErr(err)
	}
	return inline_comment, nil

}

func (impl sqlite3Impl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(sqlite3.Error); ok {
		if e.Code == sqlite3.ErrConstraint {
			msg := err.Error()
			colon := strings.LastIndex(msg, ":")
			if colon != -1 {
				return strings.TrimSpace(msg[colon:]), true
			}
			return "", true
		}
	}
	return "", false
}

func (obj *sqlite3Impl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM team_configs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM patchset_announcements;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM inline_comments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM gerrit_users;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

type Rx struct {
	db *DB
	tx *Tx
}

func (rx *Rx) UnsafeTx(ctx context.Context) (unsafe_tx *sql.Tx, err error) {
	tx, err := rx.getTx(ctx)
	if err != nil {
		return nil, err
	}
	return tx.Tx, nil
}

func (rx *Rx) getTx(ctx context.Context) (tx *Tx, err error) {
	if rx.tx == nil {
		if rx.tx, err = rx.db.Open(ctx); err != nil {
			return nil, err
		}
	}
	return rx.tx, nil
}

func (rx *Rx) Rebind(s string) string {
	return rx.db.Rebind(s)
}

func (rx *Rx) Commit() (err error) {
	if rx.tx != nil {
		err = rx.tx.Commit()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) Rollback() (err error) {
	if rx.tx != nil {
		err = rx.tx.Rollback()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) All_GerritUser_By_LastReport_Less(ctx context.Context,
	gerrit_user_last_report_less GerritUser_LastReport_Field) (
	rows []*GerritUser, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_GerritUser_By_LastReport_Less(ctx, gerrit_user_last_report_less)
}

func (rx *Rx) All_PatchsetAnnouncement_MessageHandle_By_ProjectName_And_ChangeNum_And_PatchsetNum(ctx context.Context,
	patchset_announcement_project_name PatchsetAnnouncement_ProjectName_Field,
	patchset_announcement_change_num PatchsetAnnouncement_ChangeNum_Field,
	patchset_announcement_patchset_num PatchsetAnnouncement_PatchsetNum_Field) (
	rows []*MessageHandle_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_PatchsetAnnouncement_MessageHandle_By_ProjectName_And_ChangeNum_And_PatchsetNum(ctx, patchset_announcement_project_name, patchset_announcement_change_num, patchset_announcement_patchset_num)
}

func (rx *Rx) CreateNoReturn_GerritUser(ctx context.Context,
	gerrit_user_gerrit_username GerritUser_GerritUsername_Field,
	gerrit_user_chat_id GerritUser_ChatId_Field,
	optional GerritUser_Create_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.CreateNoReturn_GerritUser(ctx, gerrit_user_gerrit_username, gerrit_user_chat_id, optional)

}

func (rx *Rx) CreateNoReturn_PatchsetAnnouncement(ctx context.Context,
	patchset_announcement_project_name PatchsetAnnouncement_ProjectName_Field,
	patchset_announcement_change_num PatchsetAnnouncement_ChangeNum_Field,
	patchset_announcement_patchset_num PatchsetAnnouncement_PatchsetNum_Field,
	patchset_announcement_message_handle PatchsetAnnouncement_MessageHandle_Field) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.CreateNoReturn_PatchsetAnnouncement(ctx, patchset_announcement_project_name, patchset_announcement_change_num, patchset_announcement_patchset_num, patchset_announcement_message_handle)

}

func (rx *Rx) CreateNoReturn_TeamConfig(ctx context.Context,
	team_config_config_key TeamConfig_ConfigKey_Field,
	team_config_config_value TeamConfig_ConfigValue_Field) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.CreateNoReturn_TeamConfig(ctx, team_config_config_key, team_config_config_value)

}

func (rx *Rx) Delete_InlineComment_By_UpdatedAt_Less(ctx context.Context,
	inline_comment_updated_at_less InlineComment_UpdatedAt_Field) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_InlineComment_By_UpdatedAt_Less(ctx, inline_comment_updated_at_less)

}

func (rx *Rx) Delete_PatchsetAnnouncement_By_Ts_Less(ctx context.Context,
	patchset_announcement_ts_less PatchsetAnnouncement_Ts_Field) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_PatchsetAnnouncement_By_Ts_Less(ctx, patchset_announcement_ts_less)

}

func (rx *Rx) Get_GerritUser_By_GerritUsername(ctx context.Context,
	gerrit_user_gerrit_username GerritUser_GerritUsername_Field) (
	gerrit_user *GerritUser, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_GerritUser_By_GerritUsername(ctx, gerrit_user_gerrit_username)
}

func (rx *Rx) Get_TeamConfig_ConfigValue_By_ConfigKey(ctx context.Context,
	team_config_config_key TeamConfig_ConfigKey_Field) (
	row *ConfigValue_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_TeamConfig_ConfigValue_By_ConfigKey(ctx, team_config_config_key)
}

func (rx *Rx) UpdateNoReturn_GerritUser_By_GerritUsername(ctx context.Context,
	gerrit_user_gerrit_username GerritUser_GerritUsername_Field,
	update GerritUser_Update_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.UpdateNoReturn_GerritUser_By_GerritUsername(ctx, gerrit_user_gerrit_username, update)
}

func (rx *Rx) UpdateNoReturn_TeamConfig_By_ConfigKey(ctx context.Context,
	team_config_config_key TeamConfig_ConfigKey_Field,
	update TeamConfig_Update_Fields) (
	err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.UpdateNoReturn_TeamConfig_By_ConfigKey(ctx, team_config_config_key, update)
}

func (rx *Rx) Update_InlineComment_By_CommentId(ctx context.Context,
	inline_comment_comment_id InlineComment_CommentId_Field,
	update InlineComment_Update_Fields) (
	inline_comment *InlineComment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_InlineComment_By_CommentId(ctx, inline_comment_comment_id, update)
}

type Methods interface {
	All_GerritUser_By_LastReport_Less(ctx context.Context,
		gerrit_user_last_report_less GerritUser_LastReport_Field) (
		rows []*GerritUser, err error)

	All_PatchsetAnnouncement_MessageHandle_By_ProjectName_And_ChangeNum_And_PatchsetNum(ctx context.Context,
		patchset_announcement_project_name PatchsetAnnouncement_ProjectName_Field,
		patchset_announcement_change_num PatchsetAnnouncement_ChangeNum_Field,
		patchset_announcement_patchset_num PatchsetAnnouncement_PatchsetNum_Field) (
		rows []*MessageHandle_Row, err error)

	CreateNoReturn_GerritUser(ctx context.Context,
		gerrit_user_gerrit_username GerritUser_GerritUsername_Field,
		gerrit_user_chat_id GerritUser_ChatId_Field,
		optional GerritUser_Create_Fields) (
		err error)

	CreateNoReturn_PatchsetAnnouncement(ctx context.Context,
		patchset_announcement_project_name PatchsetAnnouncement_ProjectName_Field,
		patchset_announcement_change_num PatchsetAnnouncement_ChangeNum_Field,
		patchset_announcement_patchset_num PatchsetAnnouncement_PatchsetNum_Field,
		patchset_announcement_message_handle PatchsetAnnouncement_MessageHandle_Field) (
		err error)

	CreateNoReturn_TeamConfig(ctx context.Context,
		team_config_config_key TeamConfig_ConfigKey_Field,
		team_config_config_value TeamConfig_ConfigValue_Field) (
		err error)

	Delete_InlineComment_By_UpdatedAt_Less(ctx context.Context,
		inline_comment_updated_at_less InlineComment_UpdatedAt_Field) (
		count int64, err error)

	Delete_PatchsetAnnouncement_By_Ts_Less(ctx context.Context,
		patchset_announcement_ts_less PatchsetAnnouncement_Ts_Field) (
		count int64, err error)

	Get_GerritUser_By_GerritUsername(ctx context.Context,
		gerrit_user_gerrit_username GerritUser_GerritUsername_Field) (
		gerrit_user *GerritUser, err error)

	Get_TeamConfig_ConfigValue_By_ConfigKey(ctx context.Context,
		team_config_config_key TeamConfig_ConfigKey_Field) (
		row *ConfigValue_Row, err error)

	UpdateNoReturn_GerritUser_By_GerritUsername(ctx context.Context,
		gerrit_user_gerrit_username GerritUser_GerritUsername_Field,
		update GerritUser_Update_Fields) (
		err error)

	UpdateNoReturn_TeamConfig_By_ConfigKey(ctx context.Context,
		team_config_config_key TeamConfig_ConfigKey_Field,
		update TeamConfig_Update_Fields) (
		err error)

	Update_InlineComment_By_CommentId(ctx context.Context,
		inline_comment_comment_id InlineComment_CommentId_Field,
		update InlineComment_Update_Fields) (
		inline_comment *InlineComment, err error)
}

type TxMethods interface {
	Methods

	Rebind(s string) string
	Commit() error
	Rollback() error
}

type txMethods interface {
	TxMethods

	deleteAll(ctx context.Context) (int64, error)
	makeErr(err error) error
}

type DBMethods interface {
	Methods

	Schema() string
	Rebind(sql string) string
}

type dbMethods interface {
	DBMethods

	wrapTx(tx *sql.Tx) txMethods
	makeErr(err error) error
}

func openpostgres(source string) (*sql.DB, error) {
	return sql.Open("postgres", source)
}

var sqlite3DriverName = func() string {
	var id [16]byte
	rand.Read(id[:])
	return fmt.Sprintf("sqlite3_%x", string(id[:]))
}()

func init() {
	sql.Register(sqlite3DriverName, &sqlite3.SQLiteDriver{
		ConnectHook: sqlite3SetupConn,
	})
}

// SQLite3JournalMode controls the journal_mode pragma for all new connections.
// Since it is read without a mutex, it must be changed to the value you want
// before any Open calls.
var SQLite3JournalMode = "WAL"

func sqlite3SetupConn(conn *sqlite3.SQLiteConn) (err error) {
	_, err = conn.Exec("PRAGMA foreign_keys = ON", nil)
	if err != nil {
		return makeErr(err)
	}
	_, err = conn.Exec("PRAGMA journal_mode = "+SQLite3JournalMode, nil)
	if err != nil {
		return makeErr(err)
	}
	return nil
}

func opensqlite3(source string) (*sql.DB, error) {
	return sql.Open(sqlite3DriverName, source)
}
